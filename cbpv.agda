{-# OPTIONS --cubical #-}

module cbpv where

open import Cubical.Foundations.Prelude renaming ( _,_ to _,,_ )
open import Data.Nat hiding ( _+_ )
open import Data.Fin hiding ( _+_ ; fold )
open import Function

-- Finite maps
_~>_ : โ {โ} -> โ -> Set โ -> Set โ
n ~> t = Fin n -> t

_,_ : โ {โ n} {t : Set โ} -> (n ~> t) -> t -> (suc n ~> t)
(f , x) zero = x
(f , x) (suc i) = f i

_~>'_ : (n : โ) -> (n ~> Set) -> Set
n ~>' P = (i : Fin n) -> P i

infixr 20 _~>_
infixr 20 _~>'_

congโ : {a b c d : Set} -> โ {aโ aโ bโ bโ cโ cโ} (f : a -> b -> c -> d) ->
        aโ โก aโ -> bโ โก bโ -> cโ โก cโ ->
        f aโ bโ cโ โก f aโ bโ cโ
congโ f pโ pโ pโ i = f (pโ i) (pโ i) (pโ i)

data Tp (n : โ) : Set where
  ๐ : Tp n
  ๐ : Tp n
  _+_ : Tp n -> Tp n -> Tp n
  _ร_ : Tp n -> Tp n -> Tp n
  _โ_ : Tp n -> Tp n -> Tp n
  ฮผ : Tp (suc n) -> Tp n
  var : Fin n -> Tp n
  cmp : Tp n -> Tp n

infixr 10 _โ_
infixl 20 _+_
infixl 30 _ร_

data Val (n : โ) : Set
data Comp (n : โ) : Set

data Val n where
  unit : Val n
  
  -- intros for _+_
  injโ : Val n -> Val n
  injแตฃ : Val n -> Val n

  -- intro for _ร_
  โจ_,_โฉ : Val n -> Val n -> Val n

  -- intro for โ
  lam : Comp (suc n) -> Val n

  -- variables
  var : Fin n -> Val n

  -- intro for ฮผ
  fold : Val n -> Val n

  delay : Comp n -> Val n

data Comp n where
  -- elim for โ
  _ยท_ : Val n -> Val n -> Comp n

  -- elim for _+_
  case_of_or_ : Val n -> Comp (suc n) -> Comp (suc n) -> Comp n

  -- elim for _ร_
  split : Val n -> Comp (suc (suc n)) -> Comp n

  -- elim for ฮผ
  unfold : Val n -> Comp n

  _>>=_ : Val n -> Comp (suc n) -> Comp n

Ren : โ -> โ -> Set
Ren n k = k ~> Fin n

wk : โ {n} -> Ren (suc n) n
wk = suc

weakenแตฃ : โ {n k} -> Ren n k -> Ren (suc n) k
weakenแตฃ = suc โ_

extendแตฃ : โ {n k} -> Ren n k -> Ren (suc n) (suc k)
extendแตฃ ฯ = weakenแตฃ ฯ , zero

-- Application of renamings

[_]vแตฃ : โ {n k} -> Ren n k -> Val k -> Val n
[_]cแตฃ : โ {n k} -> Ren n k -> Comp k -> Comp n

[ ฯ ]vแตฃ unit = unit
[ ฯ ]vแตฃ (injโ v) = injโ ([ ฯ ]vแตฃ v)
[ ฯ ]vแตฃ (injแตฃ v) = injแตฃ ([ ฯ ]vแตฃ v)
[ ฯ ]vแตฃ โจ v , vโ โฉ = โจ ([ ฯ ]vแตฃ v) , ([ ฯ ]vแตฃ vโ) โฉ
[ ฯ ]vแตฃ (lam x) = lam ([ extendแตฃ ฯ ]cแตฃ x)
[ ฯ ]vแตฃ (var x) = var (ฯ x)
[ ฯ ]vแตฃ (fold v) = fold ([ ฯ ]vแตฃ v)
[ ฯ ]vแตฃ (delay x) = delay ([ ฯ ]cแตฃ x)

[ ฯ ]cแตฃ (x ยท xโ) = [ ฯ ]vแตฃ x ยท [ ฯ ]vแตฃ xโ
[ ฯ ]cแตฃ (case x of c or cโ) =
  case ([ ฯ ]vแตฃ x)
  of [ extendแตฃ ฯ ]cแตฃ c
  or [ extendแตฃ ฯ ]cแตฃ cโ
[ ฯ ]cแตฃ (split x c) =
  split ([ ฯ ]vแตฃ x) ([ extendแตฃ (extendแตฃ ฯ) ]cแตฃ c)
[ ฯ ]cแตฃ (unfold x) = unfold ([ ฯ ]vแตฃ x)
[ ฯ ]cแตฃ (x >>= c) = [ ฯ ]vแตฃ x >>= [ extendแตฃ ฯ ]cแตฃ c

weaken-cโ : โ {n} -> Comp n -> Comp (suc n)
weaken-cโ = [ wk ]cแตฃ

weaken-vโ : โ {n} -> Val n -> Val (suc n)
weaken-vโ = [ wk ]vแตฃ

-- extension distribution lemma
r-extend-r : โ {n k j} (ฯโ : Ren n k) (ฯโ : Ren k j) ->
             extendแตฃ (ฯโ โ ฯโ) โก extendแตฃ ฯโ โ extendแตฃ ฯโ
r-extend-r ฯโ ฯโ = funExt proof where
  proof : (i : Fin _) -> extendแตฃ (ฯโ โ ฯโ) i โก (extendแตฃ ฯโ โ extendแตฃ ฯโ) i
  proof zero = refl
  proof (suc i) = refl

-- congruence of extension distribution lemma through application
r-extend-r-c : โ {n k j} (ฯโ : Ren n k) (ฯโ : Ren k j) (c : Comp (suc j)) ->
               [ extendแตฃ (ฯโ โ ฯโ) ]cแตฃ c โก [ extendแตฃ ฯโ โ extendแตฃ ฯโ ]cแตฃ c
r-extend-r-c ฯโ ฯโ c = cong (ฮป ฯ -> [ ฯ ]cแตฃ c) (r-extend-r ฯโ ฯโ)

record Foo (P Q R : โ -> โ -> Set) : Set where
  field
    [_]p : โ {n k} -> P n k -> Val k -> Val n
    [_]q : โ {n k} -> Q n k -> Val k -> Val n
    [_]r : โ {n k} -> R n k -> Val k -> Val n
    extend-P : โ {n k} -> P n k -> P (suc n) (suc k)
    extend-Q : โ {n k} -> Q n k -> Q (suc n) (suc k)
    extend-R : โ {n k} -> R n k -> R (suc n) (suc k)
    _pโq_ : โ {n k j} -> P n k -> Q k j -> R n j
    f-extend-g : โ {n k j} (f : P n k) (g : Q k j) -> extend-P f pโq extend-Q g โก extend-R (f pโq g)
    unit-eq : โ {n k j} {f : P n k} {g : Q k j} ->
      ([ f ]p โ [ g ]q) unit โก [ f pโq g ]r unit
    var-eq : โ {n k j} {f : P n k} {g : Q k j} -> (x : Fin _) ->
      ([ f ]p โ [ g ]q) (var x) โก [ f pโq g ]r (var x)

fโg-lemma-v : {P Q R : โ -> โ -> Set}
              (T : Foo P Q R) ->
              โ {n k j} ->
              (f : P n k) (g : Q k j) (v : Val j) ->
              (T.[ f ]p โ T.[ g ]q) v โก T.[ f pโq g ]r v
fโg-lemma-v T f g unit = {!!}
fโg-lemma-v T f g (injโ v) = {!!}
fโg-lemma-v T f g (injแตฃ v) = {!!}
fโg-lemma-v T f g โจ v , vโ โฉ = {!!}
fโg-lemma-v T f g (lam x) = {!!}
fโg-lemma-v T f g (var x) = {!!}
fโg-lemma-v T f g (fold v) = {!!}
fโg-lemma-v T f g (delay x) = {!!}

-- renaming-renaming composition lemmas
rโr-lemma-v : โ {n k j} (ฯโ : Ren n k) (ฯโ : Ren k j) (v : Val j) ->
              ([ ฯโ ]vแตฃ โ [ ฯโ ]vแตฃ) v โก [ ฯโ โ ฯโ ]vแตฃ v

rโr-lemma-c : โ {n k j} (ฯโ : Ren n k) (ฯโ : Ren k j) (c : Comp j) ->
              ([ ฯโ ]cแตฃ โ [ ฯโ ]cแตฃ) c โก [ ฯโ โ ฯโ ]cแตฃ c

rโr-lemma-c ฯโ ฯโ (x ยท xโ) =
  congโ _ยท_ (rโr-lemma-v ฯโ ฯโ x) (rโr-lemma-v ฯโ ฯโ xโ)
rโr-lemma-c ฯโ ฯโ (case x of cโ or cโ) =
  congโ case_of_or_
    (rโr-lemma-v ฯโ ฯโ x)
    (rโr-lemma-c (extendแตฃ ฯโ) (extendแตฃ ฯโ) cโ โ (sym $ r-extend-r-c ฯโ ฯโ cโ))
    (rโr-lemma-c (extendแตฃ ฯโ) (extendแตฃ ฯโ) cโ โ (sym $ r-extend-r-c ฯโ ฯโ cโ))
rโr-lemma-c ฯโ ฯโ (split x c) =
  congโ split
    (rโr-lemma-v ฯโ ฯโ x)
    (rโr-lemma-c (extendแตฃ (extendแตฃ ฯโ)) (extendแตฃ (extendแตฃ ฯโ)) c
      โ cong (ฮป ฯ โ [ ฯ ]cแตฃ c)
        (sym (r-extend-r (extendแตฃ ฯโ) (extendแตฃ ฯโ))
          โ cong extendแตฃ (sym $ r-extend-r ฯโ ฯโ) ))
rโr-lemma-c ฯโ ฯโ (unfold x) = cong unfold (rโr-lemma-v ฯโ ฯโ x)
rโr-lemma-c ฯโ ฯโ (x >>= c) =
  congโ _>>=_
    (rโr-lemma-v ฯโ ฯโ x)
    (rโr-lemma-c (extendแตฃ ฯโ) (extendแตฃ ฯโ) c โ (sym $ r-extend-r-c ฯโ ฯโ c))

rโr-lemma-v ฯโ ฯโ unit = refl
rโr-lemma-v ฯโ ฯโ (injโ v) = cong injโ (rโr-lemma-v ฯโ ฯโ v)
rโr-lemma-v ฯโ ฯโ (injแตฃ v) = cong injแตฃ (rโr-lemma-v ฯโ ฯโ v)
rโr-lemma-v ฯโ ฯโ โจ v , vโ โฉ =
  congโ โจ_,_โฉ (rโr-lemma-v ฯโ ฯโ v) (rโr-lemma-v ฯโ ฯโ vโ)
rโr-lemma-v ฯโ ฯโ (lam x) =
  cong lam
    (rโr-lemma-c (extendแตฃ ฯโ) (extendแตฃ ฯโ) x
      โ cong (ฮป ฯ โ [ ฯ ]cแตฃ x) (sym $ r-extend-r ฯโ ฯโ))
rโr-lemma-v ฯโ ฯโ (var x) = refl
rโr-lemma-v ฯโ ฯโ (fold v) = cong fold (rโr-lemma-v ฯโ ฯโ v)
rโr-lemma-v ฯโ ฯโ (delay x) = cong delay (rโr-lemma-c ฯโ ฯโ x)

rโr-lemma-c' : โ {n k j} (ฯโ : Ren n k) (ฯโ : Ren k j) ->
               [ ฯโ ]cแตฃ โ [ ฯโ ]cแตฃ โก [ ฯโ โ ฯโ ]cแตฃ
rโr-lemma-c' ฯโ ฯโ = funExt (rโr-lemma-c ฯโ ฯโ)

rโr-lemma-v' : โ {n k j} (ฯโ : Ren n k) (ฯโ : Ren k j) ->
               [ ฯโ ]vแตฃ โ [ ฯโ ]vแตฃ โก [ ฯโ โ ฯโ ]vแตฃ
rโr-lemma-v' ฯโ ฯโ = funExt (rโr-lemma-v ฯโ ฯโ)

-- Substitutions
Subst : โ -> โ -> Set
Subst n k = k ~> Val n

idโ : โ {n} -> Subst n n
idโ = var

single : โ {n} -> Val n -> Subst n (suc n)
single v = idโ , v

weakenโ : โ {n k} -> Subst n k -> Subst (suc n) k
weakenโ = weaken-vโ โ_

extendโ : โ {n k} -> Subst n k -> Subst (suc n) (suc k)
extendโ ฯ = weakenโ ฯ , var zero

-- Application of a substitution
[_]vโ : โ {n k} -> (ฯ : Subst n k) -> Val k -> Val n
[_]cโ : โ {n k} -> (ฯ : Subst n k) -> Comp k -> Comp n

[ ฯ ]vโ unit = unit
[ ฯ ]vโ (injโ v) = injโ ([ ฯ ]vโ v)
[ ฯ ]vโ (injแตฃ v) = injแตฃ ([ ฯ ]vโ v)
[ ฯ ]vโ โจ v , vโ โฉ = โจ [ ฯ ]vโ v , [ ฯ ]vโ vโ โฉ
[ ฯ ]vโ (lam x) = lam ([ extendโ ฯ ]cโ x)
[ ฯ ]vโ (var x) = ฯ x
[ ฯ ]vโ (fold v) = fold ([ ฯ ]vโ v)
[ ฯ ]vโ (delay x) = delay ([ ฯ ]cโ x)

[ ฯ ]cโ (x ยท xโ) = ([ ฯ ]vโ x) ยท ([ ฯ ]vโ xโ)
[ ฯ ]cโ (case x of c or cโ) =
  case ([ ฯ ]vโ x) of ([ extendโ ฯ ]cโ c) or ([ extendโ ฯ ]cโ cโ)
[ ฯ ]cโ (split x c) = split ([ ฯ ]vโ x) ([ extendโ (extendโ ฯ) ]cโ c)
[ ฯ ]cโ (unfold x) = unfold ([ ฯ ]vโ x)
[ ฯ ]cโ (x >>= c) = ([ ฯ ]vโ x) >>= ([ extendโ ฯ ]cโ c)

-- Renaming-substitution composition

_rโs_ : โ {n k j} -> Ren n k -> Subst k j -> Subst n j
_rโs_ ฯ = [ ฯ ]vแตฃ โ_

r-extend-s : โ {n k j} (ฯ : Ren n k) (ฯ : Subst k j) ->
             extendแตฃ ฯ rโs extendโ ฯ โก extendโ (ฯ rโs ฯ)
r-extend-s ฯ ฯ = funExt proof where
  proof : (x : Fin _) ->
          (extendแตฃ ฯ rโs extendโ ฯ) x โก extendโ (ฯ rโs ฯ) x
  proof zero = refl
  proof (suc x) =
    rโr-lemma-v (extendแตฃ ฯ) wk (ฯ x)
    โ
    (sym $ rโr-lemma-v wk ฯ (ฯ x))

rโs-lemma-v : โ {n k j} (ฯ : Ren n k) (ฯ : Subst k j) (v : Val j) ->
              [ ฯ ]vแตฃ ([ ฯ ]vโ v) โก [ ฯ rโs ฯ ]vโ v
rโs-lemma-c : โ {n k j} (ฯ : Ren n k) (ฯ : Subst k j) (c : Comp j) ->
              [ ฯ ]cแตฃ ([ ฯ ]cโ c) โก [ ฯ rโs ฯ ]cโ c

rโs-lemma-v ฯ ฯ unit = refl
rโs-lemma-v ฯ ฯ (injโ v) = cong injโ (rโs-lemma-v ฯ ฯ v)
rโs-lemma-v ฯ ฯ (injแตฃ v) = cong injแตฃ (rโs-lemma-v ฯ ฯ v)
rโs-lemma-v ฯ ฯ โจ v , vโ โฉ =
  congโ โจ_,_โฉ (rโs-lemma-v ฯ ฯ v) (rโs-lemma-v ฯ ฯ vโ)
rโs-lemma-v ฯ ฯ (lam x) =
  cong lam
    (rโs-lemma-c (extendแตฃ ฯ) (extendโ ฯ) x
      โ cong (ฮป ฯ โ [ ฯ ]cโ x)
        (r-extend-s ฯ ฯ))
rโs-lemma-v ฯ ฯ (var x) = refl
rโs-lemma-v ฯ ฯ (fold v) = cong fold (rโs-lemma-v ฯ ฯ v)
rโs-lemma-v ฯ ฯ (delay x) = cong delay (rโs-lemma-c ฯ ฯ x)

rโs-lemma-c ฯ ฯ (x ยท xโ) = congโ _ยท_ (rโs-lemma-v ฯ ฯ x) (rโs-lemma-v ฯ ฯ xโ)
rโs-lemma-c ฯ ฯ (case x of c or cโ) =
  congโ case_of_or_
    (rโs-lemma-v ฯ ฯ x)
    (rโs-lemma-c (extendแตฃ ฯ) (extendโ ฯ) c
      โ cong (ฮป ฯ โ [ ฯ ]cโ c) (r-extend-s ฯ ฯ))
    (rโs-lemma-c (extendแตฃ ฯ) (extendโ ฯ) cโ
      โ cong (ฮป ฯ โ [ ฯ ]cโ cโ) (r-extend-s ฯ ฯ))
rโs-lemma-c ฯ ฯ (split x c) =
  congโ split
    (rโs-lemma-v ฯ ฯ x)
    (rโs-lemma-c (extendแตฃ (extendแตฃ ฯ)) (extendโ (extendโ ฯ)) c
      โ cong (ฮป ฯ โ [ ฯ ]cโ c)
        (r-extend-s (extendแตฃ ฯ) (extendโ ฯ)
          โ cong extendโ
            (r-extend-s ฯ ฯ)))
rโs-lemma-c ฯ ฯ (unfold x) = cong unfold (rโs-lemma-v ฯ ฯ x)
rโs-lemma-c ฯ ฯ (x >>= c) =
  congโ _>>=_
    (rโs-lemma-v ฯ ฯ x)
    (rโs-lemma-c (extendแตฃ ฯ) (extendโ ฯ) c
      โ cong (ฮป ฯ -> [ ฯ ]cโ c) (r-extend-s ฯ ฯ))

_sโr_ : โ {n k j} -> Subst n k -> Ren k j -> Subst n j
_sโr_ ฯ ฯ = ฯ โ ฯ

s-extend-r : โ {n k j} (ฯ : Subst n k) (ฯ : Ren k j) ->
             extendโ ฯ sโr extendแตฃ ฯ โก extendโ (ฯ sโr ฯ)
s-extend-r ฯ ฯ = funExt proof where
  proof : (x : Fin _) ->
          (extendโ ฯ sโr extendแตฃ ฯ) x โก extendโ (ฯ sโr ฯ) x
  proof zero = refl
  proof (suc x) = refl

sโr-lemma-v : โ {n k j} (ฯ : Subst n k) (ฯ : Ren k j) (v : Val j) ->
              ([ ฯ ]vโ โ [ ฯ ]vแตฃ) v โก [ ฯ sโr ฯ ]vโ v
sโr-lemma-c : โ {n k j} (ฯ : Subst n k) (ฯ : Ren k j) (c : Comp j) ->
              ([ ฯ ]cโ โ [ ฯ ]cแตฃ) c โก [ ฯ sโr ฯ ]cโ c

sโr-lemma-v ฯ ฯ unit = refl
sโr-lemma-v ฯ ฯ (injโ v) = cong injโ (sโr-lemma-v ฯ ฯ v)
sโr-lemma-v ฯ ฯ (injแตฃ v) = cong injแตฃ (sโr-lemma-v ฯ ฯ v)
sโr-lemma-v ฯ ฯ โจ v , vโ โฉ =
  congโ โจ_,_โฉ
    (sโr-lemma-v ฯ ฯ v)
    (sโr-lemma-v ฯ ฯ vโ)
sโr-lemma-v ฯ ฯ (lam x) =
  cong lam
    (sโr-lemma-c (extendโ ฯ) (extendแตฃ ฯ) x
      โ cong (ฮป ฯ โ [ ฯ ]cโ x)
        (s-extend-r ฯ ฯ))
sโr-lemma-v ฯ ฯ (var x) = refl
sโr-lemma-v ฯ ฯ (fold v) =
  cong fold (sโr-lemma-v ฯ ฯ v)
sโr-lemma-v ฯ ฯ (delay x) = cong delay (sโr-lemma-c ฯ ฯ x)

sโr-lemma-c ฯ ฯ (x ยท xโ) =
  congโ _ยท_
    (sโr-lemma-v ฯ ฯ x)
    (sโr-lemma-v ฯ ฯ xโ)
sโr-lemma-c ฯ ฯ (case x of c or cโ) =
  congโ case_of_or_
    (sโr-lemma-v ฯ ฯ x)
    (sโr-lemma-c (extendโ ฯ) (extendแตฃ ฯ) c
      โ cong (ฮป ฯ โ [ ฯ ]cโ c) (s-extend-r ฯ ฯ))
    (sโr-lemma-c (extendโ ฯ) (extendแตฃ ฯ) cโ
      โ cong (ฮป ฯ โ [ ฯ ]cโ cโ) (s-extend-r ฯ ฯ))
sโr-lemma-c ฯ ฯ (split x c) =
  congโ split
    (sโr-lemma-v ฯ ฯ x)
    (sโr-lemma-c (extendโ (extendโ ฯ)) (extendแตฃ (extendแตฃ ฯ)) c
      โ cong (ฮป ฯ -> [ ฯ ]cโ c)
        (s-extend-r (extendโ ฯ) (extendแตฃ ฯ)
          โ cong extendโ (s-extend-r ฯ ฯ)))
sโr-lemma-c ฯ ฯ (unfold x) = cong unfold {!!}
sโr-lemma-c ฯ ฯ (x >>= c) = {!!}
